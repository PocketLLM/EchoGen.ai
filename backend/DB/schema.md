# Supabase Data Model

EchoGen.ai uses Supabase (PostgreSQL + Auth + Storage) as the system of record. The
schema aligns with the Flutter client flows and the FastAPI services.

## Tables

### `profiles`

Stores lightweight profile information that augments `auth.users`.

| Column | Type | Notes |
|--------|------|-------|
| `id` | `uuid` | Primary key, references `auth.users.id` |
| `full_name` | `text` | Display name |
| `avatar_url` | `text` | Optional avatar (from Storage) |
| `created_at` | `timestamptz` | Default `now()` |
| `updated_at` | `timestamptz` | Default `now()` |

Row Level Security (RLS): enable and grant `select, update` to authenticated users on their own row.

### `user_sessions`

Tracks sign-ins for audit and device management.

| Column | Type |
|--------|------|
| `id` | `uuid` PK |
| `user_id` | `uuid` FK → `auth.users` |
| `device` | `jsonb` (model, os, app version) |
| `ip_address` | `inet` |
| `created_at` | `timestamptz` default now() |

### `user_api_keys`

Secure vault for third-party credentials (encrypted client-side).

| Column | Type | Notes |
|--------|------|-------|
| `id` | `uuid` PK default `gen_random_uuid()` |
| `user_id` | `uuid` FK → `auth.users` (index) |
| `provider` | `text` |
| `key_alias` | `text` |
| `encrypted_key` | `text` | ciphertext + IV + tag |
| `metadata` | `jsonb` | stores scopes, usage caps |
| `created_at` | `timestamptz` default now() |
| `updated_at` | `timestamptz` default now() |

RLS: allow CRUD for owner only.

### `scraped_content`

Cross-device storage for scraped articles and uploaded transcripts.

| Column | Type |
|--------|------|
| `id` | `uuid` PK |
| `user_id` | `uuid` FK |
| `url` | `text` |
| `title` | `text` |
| `markdown` | `text` |
| `provider` | `text` | `firecrawl`, `hyperbrowser`, etc. |
| `metadata` | `jsonb` | includes `language`, `reading_time`, etc. |
| `created_at` | `timestamptz` default now() |
| `updated_at` | `timestamptz` default now() |

### `podcast_scripts`

Structured scripts returned by AI providers.

| Column | Type |
|--------|------|
| `id` | `uuid` PK |
| `user_id` | `uuid` FK |
| `source_content_id` | `uuid` FK → `scraped_content.id` (nullable) |
| `prompt` | `text` |
| `model` | `text` |
| `language` | `text` |
| `segments` | `jsonb` | array of `{speaker, content, start_time, end_time}` |
| `metadata` | `jsonb` |
| `created_at` | `timestamptz` default now() |
| `updated_at` | `timestamptz` default now() |

### `generated_podcasts`

Metadata for rendered audio and cover art stored in Supabase Storage.

| Column | Type |
|--------|------|
| `id` | `uuid` PK |
| `user_id` | `uuid` FK |
| `script_id` | `uuid` FK → `podcast_scripts.id` |
| `audio_path` | `text` | Storage path |
| `cover_art_path` | `text` | Storage path (nullable) |
| `duration_seconds` | `integer` |
| `metadata` | `jsonb` |
| `created_at` | `timestamptz` default now() |
| `updated_at` | `timestamptz` default now() |

### `processing_jobs`

Persists asynchronous job state for script generation, text-to-speech, cover art, etc.

| Column | Type |
|--------|------|
| `id` | `text` PK (generated by backend) |
| `user_id` | `uuid` FK |
| `job_type` | `text` |
| `status` | `text` | `queued`, `running`, `succeeded`, `failed` |
| `payload` | `jsonb` |
| `result` | `jsonb` |
| `error` | `text` |
| `created_at` | `timestamptz` default now() |
| `updated_at` | `timestamptz` default now() |
| `started_at` | `timestamptz` |
| `finished_at` | `timestamptz` |

### `usage_events`

Optional analytics table for tracking provider usage and costs.

| Column | Type |
|--------|------|
| `id` | `uuid` PK |
| `user_id` | `uuid` FK |
| `provider` | `text` |
| `event_type` | `text` | e.g., `script_generation`, `tts_render` |
| `payload` | `jsonb` |
| `cost_usd` | `numeric(10,4)` |
| `created_at` | `timestamptz` default now() |

## Storage Buckets

Create three buckets in Supabase Storage:

| Bucket | Access | Purpose |
|--------|--------|---------|
| `podcast-audio` | Private | Final MP3/AAC files |
| `cover-art` | Private | AI generated artwork |
| `transcripts` | Private | Source articles, transcripts, debug exports |

The backend issues signed URLs when sharing media with clients. Public buckets are discouraged
because API keys and premium audio should remain access-controlled.

## Row Level Security Recommendations

1. Enable RLS on all tables.
2. For user-owned tables (`user_api_keys`, `scraped_content`, `podcast_scripts`, `generated_podcasts`,
   `processing_jobs`, `usage_events`) add policies similar to:

```sql
create policy "Individuals can manage their rows" on public.scraped_content
for all
using (auth.uid() = user_id)
with check (auth.uid() = user_id);
```

3. Expose read-only service policies for background workers if needed.
4. Store encryption keys for API credentials in environment variables or a secrets manager.

## Database Extensions

Enable the following extensions (already available in Supabase):

- `pgcrypto` – for `gen_random_uuid()`
- `uuid-ossp` – optional alternative UUID generator
- `pg_net` – if calling external APIs from Postgres functions

## Migration Strategy

- Apply the SQL in `schema.sql` via the Supabase SQL editor.
- Use Supabase migration CLI for version control when moving beyond the skeleton.
- Keep schema diagrams updated alongside Flutter model changes.
